from pickle import PUT
from manim import *
from manim_slides import Slide

class SchoolPresent(Slide):
    def construct(self):
        def trans(p: np.ndarray) -> np.ndarray:
            return np.array([
                p[0]*p[0]-p[1]*p[1],
                p[1]*p[0]+p[1]*p[0],
                p[2]
            ])

        tex = Tex('Funkcje zespolone')
        self.play(Write(tex),run_time=2)
        self.next_slide()
        self.play(FadeOut(tex))
        self.wait(0.5)
        przyp=MathTex("i = \\sqrt{-1}")
        self.play(FadeIn(przyp,shift=DOWN))
        self.next_slide()
        equation = Tex("z" , " = " , "a" , " + ", "b", "i")
        equation[0].set_color(YELLOW)
        equation[2].set_color(RED)
        equation[4].set_color(BLUE)
        #self.add(equation)
        self.play(Transform(przyp,equation),run_time=2)
        self.remove(przyp)
        self.next_slide()

        equation2 = MathTex("z", "=" ,"r","(sin(",r"\theta",  ") + ", "cos(",r"\theta",")i)")
        equation2[0].set_color(YELLOW)
        equation2[2].set_color(RED)
        equation2[4].set_color(BLUE)
        equation2[7].set_color(BLUE)
        exp=MathTex("r",r"=\sqrt{a^{2}+b^{2}}").next_to(equation2,DOWN)
        exp[0].set_color(RED)
        exp2=MathTex(r"\theta",r"= tan^{-1}(\frac{b}{a})").next_to(exp,DOWN)
        exp2[0].set_color(BLUE)
        self.play(Transform(equation,equation2),FadeIn(exp),FadeIn(exp2))
        self.remove(equation)
        
        self.next_slide()
        equation3 = MathTex("z",r"=re^{i\theta}")
        equation3[0].set_color(YELLOW)
        self.play(Transform(equation2,equation3),FadeOut(exp),FadeOut(exp2))
        self.remove(equation2)
        self.next_slide()
        op2=MathTex(r"z_{1}z_{2}")
        op1=MathTex(r"z_{1} + z_{2}").next_to(op2,UP)
        op3=MathTex(r"\frac{z_{1}}{z_{2}}").next_to(op2,DOWN)



        opp2=Tex("(","a"," + ","b","i)"," * (","c"," + ","d","i)"," = ","a","c"," + ","a","d","i + ","b","c","i - ","b","d")
        opp1=Tex("(","a"," + ","b","i)"," + (","c"," + ","d","i)"," = ","a","+","c"," + (","b","+","d",")i").next_to(opp2,UP)
        opp3=MathTex(r"\frac{a + bi}{c + di}",r"=\frac{ac + bd}{c^{2} + d^{2}}",r" + (\frac{bc - ad}{c^{2} + d^{2}})i").next_to(opp2,DOWN)
        opp1[1].set_color(RED)
        opp1[11].set_color(RED)
        opp1[3].set_color(BLUE)
        opp1[15].set_color(BLUE)
        opp1[6].set_color(ORANGE)
        opp1[8].set_color(PURPLE)
        opp1[17].set_color(PURPLE)
        opp1[13].set_color(ORANGE)
        opp2[1].set_color(RED)
        opp2[11].set_color(RED)
        opp2[3].set_color(BLUE)
        opp2[17].set_color(BLUE)
        opp2[6].set_color(ORANGE)
        opp2[8].set_color(PURPLE)
        opp2[15].set_color(PURPLE)
        opp2[12].set_color(ORANGE)
        opp2[14].set_color(RED)
        opp2[20].set_color(BLUE)
        opp2[21].set_color(PURPLE)
        opp2[18].set_color(ORANGE)
        opp3[0][:1].set_color(RED)
        opp3[0][2:3].set_color(BLUE)
        opp3[0][5:6].set_color(ORANGE)
        opp3[0][7:8].set_color(PURPLE)
        opp3[1][1:2].set_color(RED)
        opp3[1][2:3].set_color(ORANGE)
        opp3[1][4:5].set_color(BLUE)
        opp3[1][5:6].set_color(PURPLE)
        opp3[1][7:8].set_color(BLUE)
        opp3[1][10:11].set_color(PURPLE)
        opp3[2][2:3].set_color(BLUE)
        opp3[2][3:4].set_color(ORANGE)
        opp3[2][5:6].set_color(RED)
        opp3[2][6:7].set_color(PURPLE)
        opp3[2][8:9].set_color(BLUE)
        opp3[2][11:12].set_color(PURPLE)
        
        aop2=MathTex(r"\theta = \theta_{1} + \theta_{2}", r", r = r_{1}r_{2}")
        aop3=MathTex(r"\theta = \theta_{1} - \theta_{2}", r", r = \frac{r_{1}}{r_{2}}").next_to(aop2,DOWN)

        self.play(Unwrite(equation3))
        self.wait(0.2)
        self.play(Write(op1),Write(op2),Write(op3))
        self.next_slide()
        self.play(Transform(op1,opp1),Transform(op2,opp2),Transform(op3,opp3))
        self.remove(op1,op2,op3)
        self.next_slide()    
        self.play(Unwrite(opp1),Transform(opp2,aop2),Transform(opp3,aop3))
        self.add(aop2,aop3)
        self.remove(opp1,opp2,opp3)
        self.play(aop2.animate.shift(UP))
        self.next_slide()
        grid = ComplexPlane().add_coordinates()
        track_real=ValueTracker(1)
        track_img=ValueTracker(1)
        d1 = Dot(color=YELLOW)
        #sec22 = MathTex(str(track_real.get_value()), "+" ,str(track_img.get_value()),"i").add_updater(lambda m: m.next_to(d1, UP))
        sec22=Tex("1 + i").to_corner(UP+LEFT)
        d1.add_updater(
            lambda x: x.set_x(track_real.get_value()))
        d1.add_updater(
            lambda y: y.set_y(track_img.get_value()))
        
        self.play(
                FadeOut(aop3),
                Transform(aop2,sec22),
                Create(grid, run_time=3, lag_ratio=0.1),
                Create(d1),
        )   
        self.remove(aop2,aop3)
        self.add(sec22) 
        self.remove(equation3)
        self.next_slide()
        sec23=Tex("1 + 3i").to_corner(UP+LEFT)
        self.play(track_img.animate.set_value(3),Transform(sec22,sec23))
        self.wait(1)
        sec24=Tex("-1 - i").to_corner(UP+LEFT)
        self.remove(sec22)
        self.play(track_img.animate.set_value(-1),track_real.animate.set_value(-1),Transform(sec23,sec24))
        self.next_slide()
        arrow=Line(ORIGIN,[track_real.get_value(),track_img.get_value(),0],buff=0)
        rep=Line(ORIGIN,RIGHT)
        ang=Angle(arrow,rep,other_angle=True)
        sec25=MathTex(r"\theta=225^{\circ}",", r=\\sqrt{2}").to_corner(UP+LEFT)
        self.remove(sec23)
        self.play(FadeIn(arrow),FadeIn(ang),Transform(sec24,sec25))
        self.remove(sec24)
        self.next_slide()
        sec26=MathTex(r"f(z) = z^{2}").to_corner(UP+LEFT)
        self.play(Uncreate(ang),Uncreate(arrow),Uncreate(d1),Transform(sec25,sec26))
        self.remove(sec25)
        self.next_slide()
        grad=ComplexPlane()
        grad.prepare_for_nonlinear_transform()
        self.play(Create(grad))
        self.play(ApplyPointwiseFunction(trans,grad))
        self.next_slide()
        func = lambda pos: ((pos[0] * UR + pos[1] * LEFT) - pos) / 3
        self.add(ArrowVectorField(func))
        self.wait()
